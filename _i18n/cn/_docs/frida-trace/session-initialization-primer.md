此页面描述了 frida-trace `--init-session` / `-S` 命令行选项的用途，以及如何在您的工作中使用它。

## 什么是 --init-session 选项？

`--init-session` 选项在 frida-trace 引擎初始化阶段执行任意数量的用户编写的 JavaScript 代码文件。这些文件在调用第一个函数处理程序之前执行。

它的强大之处在于能够定义全局可见的函数并将数据存储在全局 `state` 对象中，该对象作为参数传递给调用的每个处理程序。

`state` 对象允许您在函数调用之间维护信息。存储在 `state` 中的数据可供所有调用的处理程序访问。

## --init-session 选项的用途

`--init-session` / `-S` 选项保证您选择的 JavaScript 源代码在 frida-trace 引擎开始跟踪之前执行。此功能的可能应用包括：

1. 执行自定义代码，创建您选择的代码和数据对象，并在调用第一个函数处理程序之前执行此操作。
2. 创建共享代码库，允许共享微调和调试过的 JavaScript 代码，这些代码可以由任何处理程序在任何时间全局调用。

frida-trace JavaScript 代码通常编写为一次性的“用完即弃”代码。但是，如果您发现自己经常在处理程序和项目之间复制和粘贴代码，请考虑将代码保存在共享库中。编写并调试后，您可以在未来的项目中重用这些函数和数据。

## 详细示例：创建共享代码库

在此示例中，我们演示使用 `--init-session` / `-S` 选项来增强对 Microsoft Windows `ExtTextOutW()` 函数的跟踪。我们以自上而下的方式描述组件，从 ExtTextOutW.js JavaScript 处理程序函数开始，一直到共享代码文件。

### ExtTextOutW()：函数签名

在我的 Windows 系统中，要监视的 [ExtTextOutW()][] 函数位于 *gdi32full.dll* 中。这是该函数的 C 语法：

{% highlight c %}
BOOL ExtTextOutA(
  HDC        hdc,
  int        x,
  int        y,
  UINT       options,
  const RECT *lprect,
  LPCSTR     lpString,
  UINT       c,
  const INT  *lpDx
);
{% endhighlight %}

利用我们共享代码库中的 JavaScript 代码，我们生成增强的跟踪输出。

### 增强的跟踪输出

在展示处理程序代码和共享代码库之前，这里是增强的跟踪输出本身：

{% highlight console %}
c:\project> frida-trace -p 6980 --decorate -i "gdi32full.dll!ExtTextOutW" -S core.js -S ms-windows.js
Instrumenting...
ExtTextOutW: Loaded handler at "c:\\project\\__handlers__\\gdi32full.dll\\ExtTextOutW.js"
Started tracing 1 function. Press Ctrl+C to stop.
           /* TID 0x3ab8 */
  2695 ms  ---------------------------------------------
  2695 ms  ExtTextOutW() [gdi32full.dll]
  2695 ms  x: 0
  2695 ms  y: 0
  2695 ms  options: ETO_OPAQUE
  2695 ms  lprect [20 bytes]
                           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
                00b9c81c  00 00 00 00 01 00 00 00 01 00 00 00 98 02 00 00  ................
                00b9c82c  26 90 b2 b3                                      &...
  2695 ms  lprect: (left, top, right, bottom) = (0, 1, 1, 664)
  2695 ms  c: 0
  2696 ms  x (exit): 0
  2696 ms  y (exit): 0
  . . .
  2788 ms  ---------------------------------------------
  2788 ms  ExtTextOutW() [gdi32full.dll]
  2788 ms  x: 1
  2788 ms  y: 0
  2788 ms  options: ETO_CLIPPED | ETO_IGNORELANGUAGE
  2788 ms  lprect [20 bytes]
                      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
           00b9eaac  00 00 00 00 00 00 00 00 4d 00 00 00 0f 00 00 00  ........M.......
           00b9eabc  0a 78 7e c1                                      .x~.
  2788 ms  lprect: (left, top, right, bottom) = (0, 0, 77, 15)
  2788 ms  lpString [50 bytes]
                      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
           1aa90148  43 00 61 00 6c 00 69 00 62 00 72 00 69 00 20 00  C.a.l.i.b.r.i. .
           1aa90158  28 00 42 00 6f 00 64 00 79 00 29 00 29 00 75 00  (.B.o.d.y.).).u.
           1aa90168  20 00 77 00 61 00 6e 00 20 00 20 00 74 00 6f 00   .w.a.n. . .t.o.
           1aa90178  20 00                                             .
  2788 ms  *lpString: "Calibri (Body))u wan  to do"
  2788 ms  c: 14
  2788 ms  lpDx [4 bytes]
                      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
           09e71208  08 00 00 00                                      ....
  2788 ms  *lpDx: 8
  2789 ms  x (exit): 0
  2789 ms  y (exit): 0
{% endhighlight %}

注意以下跟踪增强：

- `options` 字段转换为文本形式
- `lprect` 内存指针显示为十六进制内存转储和文本字符串
- `lpString` 内存指针显示为十六进制内存转储和文本字符串
- `lpDx` 整数指针显示为十六进制内存转储和整数

文本转换和十六进制内存转储是我们共享代码库中的函数。让我们看看我们的 `ExtTextOutW()` 处理程序 JavaScript 代码，它将使用共享代码。

### 处理程序：ExtTextOutW.js

这是我们的 ExeTextOutW() 处理程序代码。我们通过调用共享代码函数来增强它。这些函数存在于外部作用域中，因为在会话脚本中定义的任何顶级函数对所有处理程序都可见。这些函数是在 frida-trace 通过 `--init-session` / `-S` 命令行选项执行共享代码 JavaScript 文件时定义的。

{% highlight js %}
/*
 * Auto-generated by Frida. Please modify to match the signature of ExtTextOutW.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
  onEnter(log, args, state) {
    /*
     * C syntax:
     *
     * BOOL ExtTextOutW(
     *   HDC        hdc,
     *   int        x,
     *   int        y,
     *   UINT       options,
     *   const RECT *lprect,
     *   LPCWSTR    lpString,
     *   UINT       c,
     *   const INT  *lpDx
     * );
    */

    log('---------------------------------------------');
    log('ExtTextOutW() [gdi32full.dll]');

    cloneArgs(args, 8, this);
    const [, x, y, options, lprect, lpString, c, lpDx] = this.args;

    log(`x: ${x.toInt32()}`);
    log(`y: ${y.toInt32()}`);

    log(`options: ${decodeExttextoutOptions(options)}`);

    if (!lprect.isNull()) {
      prettyHexdump(log, 'lprect', lprect, 20);
      log(`lprect: ${rectStructToString(lprect)}`);
    }

    if (!lpString.isNull()) {
      prettyHexdump(log, 'lpString', lpString, 50);
      log(`*lpString: "${lpString.readUtf16String()}"`);
    }

    log(`c: ${c.toUInt32()}`);

    if (!lpDx.isNull()) {
      prettyHexdump(log, 'lpDx', lpDx, 4);
      log(`*lpDx: ${lpDx.readU32()}`);
    }
  },

  onLeave(log, retval, state) {
    /*
     * We can access the onEnter arguments using `this.args`,
     * as cloneArgs() copied them there.
     */
    const [, x, y] = this.args;
    log(`x (exit): ${x.toInt32()}`);
    log(`y (exit): ${y.toInt32()}`);
  }
}
{% endhighlight %}

请注意，除了调用标准 Frida 函数（例如 `toInt32()`、`isNull()`、`readUtf16String()`）之外，还有对我们共享代码函数的调用（例如 `cloneArgs()`、`decodeExttextoutOptions()`、`prettyHexdump()`、`rectStructToString()`）。共享代码函数已经过调试和完善，随时可以被任何处理程序调用。

### 共享代码：core.js

“core.js”共享代码库包含核心或基本函数，旨在供 frida-trace 处理程序和共享代码库重用。

编写共享代码库很简单：您的共享库源文件定义函数和数据对象，将后者存储在全局 `state` 对象中。一旦存储在那里，任何处理程序都可以通过 `state.propertyName` 访问它们。

{% highlight js %}
/*
 * Collection of useful general-purpose Frida handler functions.
 */

/**
 * Creates a true JavaScript array as `invCtx.args`.  This array can be accessed
 * in the handler's onLeave().
 *
 * @param {NativePointer[]} args - The `args` array as passed to onEnter().
 * @param {number} numArgs - The number of meaningful arguments in `args`. This
 *     function has no way of determining the number of actual arguments because
 *     `args` is a virtual array.
 * @param {InvocationContext} invCtx - The `this` object of the calling onEnter().
 * @returns {NativePointer[]} Copy of `args`.
 */
function cloneArgs(args, numArgs, invCtx) {
  const items = [];
  for (let i = 0; i !== numArgs; i++)
    items.push(args[i]);
  invCtx.args = items;
}

/**
 * Returns a string describing the bitflags set in `value`.
 *
 * @param {number} value - A value consisting of zero or more bitflags.
 * @param {Map<number, string>} spec - A Map between:
 *     [hex value] -> [flag descriptive string]
 *     For example:
 *       new Map([
 *          [0x0004: 'ETO_CLIPPED'],
 *          [0x0010: 'ETO_GLYPH_INDEX'],
 *          ...
 *       ])
 * @returns {string} Flag names delimited by '|', or '0' if none are set.
 */
function decodeBitflags(value, spec) {
  if (value === 0)
    return '0';

  const flags = [];
  let pending = value;

  for (const [flagValue, flagName] of spec.entries()) {
    if ((value & flagValue) !== 0) {
      flags.push(flagName);
      pending &= ~flagValue;
      if (pending === 0)
        break;
    }
  }

  if (pending !== 0)
    flags.push(`0x${pending.toString(16)}`);

  return flags.join(' | ');
}

/**
 * Outputs the hex dump results to the log stream.  If you only want the dump
 * lines without outputing them to the log stream, use prettyHexdumpLines().
 *
 * @param {function} log - The log function to output to.
 * @param {string} desc - Descriptive text, printed together with the hex dump.
 * @param {NativePointer} address - Memory location to dump.
 * @param {number} length - Number of bytes to dump.
 */
function prettyHexdump(log, desc, address, length) {
  const lines = [];
  prettyHexdumpLines(lines, desc, address, length);
  log(lines.join('\n'));
}

/**
 * Produces a somewhat more elegant hex dump, based on Frida's own hexdump().
 * It does not output the hex dump to any stream, but rather returns the hex
 * dump lines in an array.  It is up to the caller to decide where to, and how,
 * to output the dump lines.
 *
 * @param {string[]} lines - Caller-provided array that will return the hex dump
 *     lines.
 * @param {string} desc - Descriptive text, printed together with the hex dump.
 * @param {NativePointer} address - Memory location to dump.
 * @param {number} length - Number of bytes to dump.
 * @param {string} [indent='\t\t'] - String to prepend to each dump line.
 */
function prettyHexdumpLines(lines, desc, address, length, indent = '\t\t') {
  lines.push(`${desc} [${length} bytes]`);

  try {
      const s = hexdump(address, { length });
      for (const line of s.split('\n')) {
        lines.push(`${indent}${line}`);
      }
  } catch (e) {
    lines.push(`${indent}WARNING: address is NOT VALID (${address})`);
  }
}
{% endhighlight %}

### 共享代码：ms-windows.js

“ms-windows.js”共享代码库包含与 MS Windows 相关的实用函数，并构建在 `core.js` 库之上。

{% highlight js %}
/*
 * Collection of useful Frida handler functions for MS Windows.
 */

const extTextOptionsSpec = new Map([
  [0x00004, 'ETO_CLIPPED'],
  [0x00010, 'ETO_GLYPH_INDEX'],
  [0x01000, 'ETO_IGNORELANGUAGE'],
  [0x00800, 'ETO_NUMERICSLATIN'],
  [0x00400, 'ETO_NUMERICSLOCAL'],
  [0x00002, 'ETO_OPAQUE'],
  [0x02000, 'ETO_PDY'],
  [0x00080, 'ETO_RTLREADING'],
  [0x10000, 'ETO_REVERSE_INDEX_MAP'],
]);

/**
 * Decodes ExtTextOutW() `options` bit flags.
 *
 * @param {number} flags - A DWORD consisting of the `options` bit flags used
 *     by ExtTextOutW().
 * @returns {string} Options delimited by '|', or '0' if none are set.
 */
function decodeExttextoutOptions(flags) {
  return decodeBitflags(flags, extTextOptionsSpec);
}

/**
 * Returns the four RECT values as a string of the form:
 *     (left, top, right, bottom) = (0, 0, 77, 15)
 *
 * @param {NativePointer} lprect - Pointer to a Windows RECT object.  The memory
 *     consists of four (4) contiguous LONG values, corresponding to the left,
 *     top, right, and bottom values, respectively.
 * @returns {string} Description of the RECT.
 */
function rectStructToString(lprect) {
  if (lprect.isNull()) {
    return 'LPRECT is null';
  }

  const left   = lprect.readU32();
  const top    = lprect.add(4).readU32();
  const right  = lprect.add(8).readU32();
  const bottom = lprect.add(12).readU32();

  return `(left, top, right, bottom) = (${left}, ${top}, ${right}, ${bottom})`;
}
{% endhighlight %}

两个 `-S` 命令行选项提供了“core.js”和“ms-windows.js”共享库源文件的路径。

用光标触摸 Word 应用程序中的任何内容都会生成 ExtTextOutW() 跟踪。

## 考虑要点

以下是使用 `-S` 选项时需要考虑的一些要点。

### 使用不同的代码源文件对共享函数进行分组

为了清晰起见，您可以为不同的函数组拥有多个共享代码文件。在上面的示例中，通用和基本函数位于“core.js”中，而 MS Windows 特定函数位于“ms-windows.js”中。在其他项目中，您可能有用于 Android 相关函数、Linux 函数等的文件。

### 实现命名空间

随着您使用的共享库代码文件数量的增加，您可能会遇到由于“命名空间污染”而导致的名称冲突。如果两个不同的共享代码文件实现具有相同名称的函数，则可能会发生这种情况。如果在您自己的组织内，您可以修改名称。但是，如果您使用的是第三方共享代码库，这可能会更困难。

一种可能的解决方案是让共享库将其函数存储在描述性命名的全局对象上，并相应地将数据存储在“state”上。

以下是您可能如何实现它：

{% highlight js %}
global.MyLibrary = {
  doX() {
  },
  doY() {
  }
};
{% endhighlight %}


[ExtTextOutW()]: https://web.archive.org/web/20191222090821/https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-exttextoutw
