Frida 通过其强大的插桩核心 Gum（用 C 编写）提供动态插桩。因为这种插桩逻辑容易发生变化，所以您通常希望用脚本语言编写它，以便在开发和维护它时获得较短的反馈循环。这就是 GumJS 发挥作用的地方。只需几行 C 代码，您就可以在运行时内运行一段 JavaScript，该运行时具有对 Gum API 的完全访问权限，允许您 hook 函数、枚举加载的库、它们的导入和导出函数、读写内存、扫描内存模式等。

## 目录
  1. [注入](#注入)
  1. [嵌入](#嵌入)
  1. [预加载](#预加载)

## 注入

然而，大多数时候，您希望启动一个现有的程序，附加到一个正在运行的程序，或者在它被启动时劫持它，然后在其中运行您的插桩逻辑。由于这是使用 Frida 的一种非常常见的方式，因此这也是我们大部分文档关注的内容。此功能由 frida-core 提供，它充当物流层，将 GumJS 打包到一个共享库中，将其注入到现有软件中，并提供一个双向通信通道，以便在需要时与您的脚本进行对话，并在稍后卸载它们。除了这个核心功能之外，frida-core 还允许您枚举已安装的应用、正在运行的进程和连接的设备。连接的设备通常是运行 *frida-server* 的 iOS 和 Android 设备。该组件本质上只是一个守护进程，它通过 TCP 暴露 frida-core，默认监听 *localhost:27042*。

## 嵌入

有时无法在[注入](#注入)模式下使用 Frida，例如在未越狱的 iOS 和 Android 系统上。对于这种情况，我们为您提供 *frida-gadget*，这是一个共享库，您应该将其嵌入到要插桩的程序中。只需加载该库，它就允许您使用现有的基于 Frida 的工具（如 [frida-trace][]）远程与其交互。它还支持完全自主的方法，即它可以从文件系统运行脚本，而无需任何外部通信。

在此处阅读有关 Gadget 的更多信息：[Gadget](/docs/gadget/)。

## 预加载

也许您熟悉 *LD_PRELOAD* 或 *DYLD_INSERT_LIBRARIES*？如果有 *JS_PRELOAD* 不是很酷吗？这就是上一节中讨论的共享库 *frida-gadget* 在配置为通过从文件系统加载脚本来自主运行时非常有用的地方。

在此处阅读有关 Gadget 的更多信息：[Gadget](/docs/gadget/)。


[frida-trace]: /docs/frida-trace/
